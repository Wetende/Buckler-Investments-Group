---
description: React best practices and performance patterns for DashLite admin interface
globs: admin/src/**/*.jsx,admin/src/**/*.tsx,admin/src/**/*.js,admin/src/**/*.ts
alwaysApply: true
---

# Admin React Patterns & Performance

Purpose: Establish React best practices, performance optimization patterns, and admin-specific development guidelines for the DashLite admin interface.

## React Component Patterns

### Admin Page Structure
```jsx
// admin/src/pages/UserManagement.jsx
import React, { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import Head from '@/layout/head/Head';
import Content from '@/layout/content/Content';
import { 
    Block, BlockHead, BlockContent, BlockTitle, BlockBetween 
} from '@/components/Component';

// Lazy load admin components for better performance
const UserTable = React.lazy(() => import('../components/UserTable'));
const UserForm = React.lazy(() => import('../components/UserForm'));

const UserManagement = () => {
    return (
        <React.Fragment>
            <Head title="User Management" />
            <Content>
                <ErrorBoundary
                    FallbackComponent={AdminErrorFallback}
                    onError={(error, errorInfo) => {
                        console.error('Admin page error:', error, errorInfo);
                        // Send to error reporting service
                    }}
                >
                    <BlockHead size="sm">
                        <BlockBetween>
                            <div>
                                <BlockTitle page>User Management</BlockTitle>
                                <BlockDes className="text-soft">
                                    <p>Manage platform users, roles, and permissions.</p>
                                </BlockDes>
                            </div>
                        </BlockBetween>
                    </BlockHead>
                    
                    <Block>
                        <BlockContent>
                            <Suspense fallback={<AdminTableSkeleton />}>
                                <UserTable />
                            </Suspense>
                        </BlockContent>
                    </Block>
                </ErrorBoundary>
            </Content>
        </React.Fragment>
    );
};

export default UserManagement;
```

### Admin Error Boundary
```jsx
// admin/src/components/common/AdminErrorBoundary.jsx
import React from 'react';
import { Block, BlockContent, Button, Icon } from '@/components/Component';

const AdminErrorFallback = ({ error, resetErrorBoundary }) => {
    return (
        <Block>
            <BlockContent>
                <div className="nk-block-middle text-center">
                    <div className="nk-block-head">
                        <div className="nk-block-head-content">
                            <Icon 
                                name="alert-circle" 
                                className="text-danger"
                                style={{ fontSize: '4rem' }}
                            />
                            <h4 className="nk-block-title mt-3">
                                Something went wrong
                            </h4>
                            <div className="nk-block-des">
                                <p className="text-soft">
                                    An error occurred while loading this section.
                                </p>
                                {process.env.NODE_ENV === 'development' && (
                                    <details className="mt-3 text-left">
                                        <summary>Error Details</summary>
                                        <pre className="text-danger small mt-2">
                                            {error.message}
                                        </pre>
                                    </details>
                                )}
                            </div>
                        </div>
                        <div className="nk-block-head-sub">
                            <Button 
                                color="primary" 
                                outline
                                onClick={resetErrorBoundary}
                            >
                                <Icon name="reload" />
                                <span>Try Again</span>
                            </Button>
                        </div>
                    </div>
                </div>
            </BlockContent>
        </Block>
    );
};

export default AdminErrorFallback;
```

### Admin Hook Patterns
```jsx
// admin/src/hooks/useAdminTable.js
import { useState, useMemo, useCallback } from 'react';
import { useQuery } from '@tanstack/react-query';

export const useAdminTable = ({
    queryKey,
    queryFn,
    initialPageSize = 20,
    initialSort = { field: 'created_at', direction: 'desc' }
}) => {
    const [currentPage, setCurrentPage] = useState(1);
    const [pageSize, setPageSize] = useState(initialPageSize);
    const [sort, setSort] = useState(initialSort);
    const [filters, setFilters] = useState({});
    const [searchQuery, setSearchQuery] = useState('');

    // Memoize query parameters to prevent unnecessary re-renders
    const queryParams = useMemo(() => ({
        page: currentPage,
        page_size: pageSize,
        sort_by: sort.field,
        sort_direction: sort.direction,
        search: searchQuery,
        ...filters
    }), [currentPage, pageSize, sort, searchQuery, filters]);

    const {
        data,
        isLoading,
        error,
        refetch,
        isFetching
    } = useQuery({
        queryKey: [...queryKey, queryParams],
        queryFn: () => queryFn(queryParams),
        keepPreviousData: true, // Maintain data while loading new page
        staleTime: 2 * 60 * 1000, // Admin data stale time
    });

    // Memoized handlers to prevent child re-renders
    const handlePageChange = useCallback((page) => {
        setCurrentPage(page);
    }, []);

    const handleSortChange = useCallback((field, direction) => {
        setSort({ field, direction });
        setCurrentPage(1); // Reset to first page when sorting
    }, []);

    const handleFilterChange = useCallback((newFilters) => {
        setFilters(prev => ({ ...prev, ...newFilters }));
        setCurrentPage(1); // Reset to first page when filtering
    }, []);

    const handleSearch = useCallback((query) => {
        setSearchQuery(query);
        setCurrentPage(1); // Reset to first page when searching
    }, []);

    const clearFilters = useCallback(() => {
        setFilters({});
        setSearchQuery('');
        setCurrentPage(1);
    }, []);

    return {
        // Data
        data: data?.items || [],
        totalItems: data?.total || 0,
        currentPage,
        pageSize,
        totalPages: Math.ceil((data?.total || 0) / pageSize),
        
        // State
        isLoading,
        isFetching,
        error,
        sort,
        filters,
        searchQuery,
        
        // Actions
        handlePageChange,
        handleSortChange,
        handleFilterChange,
        handleSearch,
        clearFilters,
        refetch,
        
        // Pagination helpers
        hasNextPage: currentPage < Math.ceil((data?.total || 0) / pageSize),
        hasPreviousPage: currentPage > 1,
    };
};
```

### Admin Form Hook
```jsx
// admin/src/hooks/useAdminForm.js
import { useState, useCallback } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'react-toastify';

export const useAdminForm = ({
    schema,
    defaultValues = {},
    onSubmit,
    onSuccess,
    onError,
    invalidateQueries = []
}) => {
    const [isSubmitting, setIsSubmitting] = useState(false);
    const queryClient = useQueryClient();

    const form = useForm({
        resolver: zodResolver(schema),
        defaultValues,
        mode: 'onChange' // Validate on change for better UX
    });

    const mutation = useMutation({
        mutationFn: onSubmit,
        onMutate: () => {
            setIsSubmitting(true);
        },
        onSuccess: (data, variables) => {
            // Invalidate related queries
            invalidateQueries.forEach(queryKey => {
                queryClient.invalidateQueries({ queryKey });
            });
            
            // Reset form on success
            form.reset();
            
            // Show success message
            toast.success('Operation completed successfully!');
            
            // Call custom success handler
            onSuccess?.(data, variables);
        },
        onError: (error, variables, context) => {
            // Handle validation errors from server
            if (error.response?.data?.validation_errors) {
                Object.entries(error.response.data.validation_errors).forEach(([field, messages]) => {
                    form.setError(field, {
                        type: 'server',
                        message: Array.isArray(messages) ? messages[0] : messages
                    });
                });
            } else {
                toast.error(error.response?.data?.detail || 'Operation failed');
            }
            
            // Call custom error handler
            onError?.(error, variables, context);
        },
        onSettled: () => {
            setIsSubmitting(false);
        }
    });

    const handleSubmit = useCallback((data) => {
        mutation.mutate(data);
    }, [mutation]);

    return {
        form,
        handleSubmit: form.handleSubmit(handleSubmit),
        isSubmitting: isSubmitting || mutation.isLoading,
        error: mutation.error,
        reset: form.reset,
        setValue: form.setValue,
        watch: form.watch,
        formState: form.formState
    };
};
```

## Performance Optimization Patterns

### Memoized Admin Components
```jsx
// admin/src/components/AdminTableRow.jsx
import React, { memo } from 'react';
import { DataTableItem, DataTableRow, Button, UserAvatar } from '@/components/Component';

const AdminTableRow = memo(({ 
    item, 
    onEdit, 
    onDelete, 
    onSelect,
    isSelected = false 
}) => {
    // Memoize expensive calculations
    const statusBadgeClass = useMemo(() => {
        switch (item.status) {
            case 'active': return 'badge-outline-success';
            case 'inactive': return 'badge-outline-warning';
            case 'suspended': return 'badge-outline-danger';
            default: return 'badge-outline-info';
        }
    }, [item.status]);

    const handleEdit = useCallback(() => {
        onEdit(item);
    }, [onEdit, item]);

    const handleDelete = useCallback(() => {
        onDelete(item);
    }, [onDelete, item]);

    const handleSelect = useCallback((checked) => {
        onSelect(item.id, checked);
    }, [onSelect, item.id]);

    return (
        <DataTableItem>
            <DataTableRow>
                <div className="custom-control custom-checkbox">
                    <input 
                        type="checkbox" 
                        className="custom-control-input" 
                        id={`select_${item.id}`}
                        checked={isSelected}
                        onChange={(e) => handleSelect(e.target.checked)}
                    />
                    <label className="custom-control-label" htmlFor={`select_${item.id}`}></label>
                </div>
            </DataTableRow>
            
            <DataTableRow>
                <div className="user-card">
                    <UserAvatar 
                        text={item.name}
                        theme={item.avatar_theme || 'primary'}
                    />
                    <div className="user-info">
                        <span className="tb-lead">{item.name}</span>
                        <span className="sub-text">{item.email}</span>
                    </div>
                </div>
            </DataTableRow>
            
            <DataTableRow size="mb">
                <span className={`badge ${statusBadgeClass}`}>
                    {item.status}
                </span>
            </DataTableRow>
            
            <DataTableRow className="nk-tb-col-tools">
                <ul className="nk-tb-actions gx-1">
                    <li>
                        <Button
                            size="sm"
                            color="primary"
                            outline
                            onClick={handleEdit}
                        >
                            Edit
                        </Button>
                    </li>
                    <li>
                        <Button
                            size="sm"
                            color="danger"
                            outline
                            onClick={handleDelete}
                        >
                            Delete
                        </Button>
                    </li>
                </ul>
            </DataTableRow>
        </DataTableItem>
    );
}, (prevProps, nextProps) => {
    // Custom comparison for memo
    return (
        prevProps.item.id === nextProps.item.id &&
        prevProps.item.status === nextProps.item.status &&
        prevProps.item.updated_at === nextProps.item.updated_at &&
        prevProps.isSelected === nextProps.isSelected
    );
});

AdminTableRow.displayName = 'AdminTableRow';

export default AdminTableRow;
```

### Virtual Scrolling for Large Lists
```jsx
// admin/src/components/VirtualizedAdminTable.jsx
import React, { useMemo } from 'react';
import { FixedSizeList as List } from 'react-window';
import { DataTable, DataTableBody } from '@/components/Component';
import AdminTableRow from './AdminTableRow';

const VirtualizedAdminTable = ({
    data = [],
    height = 600,
    itemHeight = 60,
    onEdit,
    onDelete,
    selectedItems = new Set()
}) => {
    // Memoize row renderer to prevent unnecessary re-renders
    const Row = useMemo(() => ({ index, style }) => {
        const item = data[index];
        
        return (
            <div style={style}>
                <AdminTableRow
                    item={item}
                    onEdit={onEdit}
                    onDelete={onDelete}
                    isSelected={selectedItems.has(item.id)}
                />
            </div>
        );
    }, [data, onEdit, onDelete, selectedItems]);

    if (data.length === 0) {
        return (
            <div className="text-center p-4">
                <p className="text-soft">No data available</p>
            </div>
        );
    }

    return (
        <DataTable>
            <DataTableBody>
                <List
                    height={height}
                    itemCount={data.length}
                    itemSize={itemHeight}
                    overscanCount={5} // Render extra items for smooth scrolling
                >
                    {Row}
                </List>
            </DataTableBody>
        </DataTable>
    );
};

export default React.memo(VirtualizedAdminTable);
```

### Admin Context Provider
```jsx
// admin/src/context/AdminContext.jsx
import React, { createContext, useContext, useReducer, useMemo } from 'react';

// Admin state management
const AdminContext = createContext();

const adminReducer = (state, action) => {
    switch (action.type) {
        case 'SET_LOADING':
            return { ...state, isLoading: action.payload };
        
        case 'SET_USER':
            return { ...state, user: action.payload };
        
        case 'SET_PERMISSIONS':
            return { ...state, permissions: action.payload };
        
        case 'SET_SIDEBAR_COLLAPSED':
            return { ...state, sidebarCollapsed: action.payload };
        
        case 'SET_THEME':
            return { ...state, theme: action.payload };
        
        case 'ADD_NOTIFICATION':
            return {
                ...state,
                notifications: [...state.notifications, action.payload]
            };
        
        case 'REMOVE_NOTIFICATION':
            return {
                ...state,
                notifications: state.notifications.filter(n => n.id !== action.payload)
            };
        
        default:
            return state;
    }
};

const initialState = {
    user: null,
    permissions: [],
    isLoading: false,
    sidebarCollapsed: false,
    theme: 'light',
    notifications: []
};

export const AdminProvider = ({ children }) => {
    const [state, dispatch] = useReducer(adminReducer, initialState);

    // Memoize context value to prevent unnecessary re-renders
    const contextValue = useMemo(() => ({
        state,
        dispatch,
        // Helper functions
        setLoading: (loading) => dispatch({ type: 'SET_LOADING', payload: loading }),
        setUser: (user) => dispatch({ type: 'SET_USER', payload: user }),
        setPermissions: (permissions) => dispatch({ type: 'SET_PERMISSIONS', payload: permissions }),
        toggleSidebar: () => dispatch({ 
            type: 'SET_SIDEBAR_COLLAPSED', 
            payload: !state.sidebarCollapsed 
        }),
        setTheme: (theme) => dispatch({ type: 'SET_THEME', payload: theme }),
        addNotification: (notification) => dispatch({ 
            type: 'ADD_NOTIFICATION', 
            payload: { ...notification, id: Date.now() }
        }),
        removeNotification: (id) => dispatch({ type: 'REMOVE_NOTIFICATION', payload: id }),
        
        // Permission helpers
        hasPermission: (permission) => state.permissions.includes(permission),
        isAdmin: () => state.user?.role === 'admin',
        canManage: (resource) => state.permissions.includes(`manage_${resource}`)
    }), [state]);

    return (
        <AdminContext.Provider value={contextValue}>
            {children}
        </AdminContext.Provider>
    );
};

export const useAdmin = () => {
    const context = useContext(AdminContext);
    if (!context) {
        throw new Error('useAdmin must be used within an AdminProvider');
    }
    return context;
};

// Permission guard component
export const AdminPermissionGuard = ({ permission, fallback = null, children }) => {
    const { hasPermission } = useAdmin();
    
    if (!hasPermission(permission)) {
        return fallback;
    }
    
    return children;
};
```

## Admin Loading & Skeleton Patterns

### Admin Skeleton Components
```jsx
// admin/src/components/skeletons/AdminSkeletons.jsx
import React from 'react';

export const AdminTableSkeleton = ({ rows = 5 }) => (
    <div className="nk-tb-list">
        {Array.from({ length: rows }).map((_, index) => (
            <div key={index} className="nk-tb-item animate-pulse">
                <div className="nk-tb-col">
                    <div className="user-card">
                        <div className="user-avatar bg-gray-200 rounded-circle" style={{ width: 40, height: 40 }}></div>
                        <div className="user-info ml-3">
                            <div className="bg-gray-200 h-4 w-24 rounded mb-1"></div>
                            <div className="bg-gray-200 h-3 w-32 rounded"></div>
                        </div>
                    </div>
                </div>
                <div className="nk-tb-col tb-col-mb">
                    <div className="bg-gray-200 h-4 w-16 rounded"></div>
                </div>
                <div className="nk-tb-col nk-tb-col-tools">
                    <div className="bg-gray-200 h-8 w-20 rounded"></div>
                </div>
            </div>
        ))}
    </div>
);

export const AdminCardSkeleton = () => (
    <div className="card card-bordered animate-pulse">
        <div className="card-inner">
            <div className="bg-gray-200 h-4 w-32 rounded mb-3"></div>
            <div className="bg-gray-200 h-8 w-48 rounded mb-2"></div>
            <div className="bg-gray-200 h-3 w-full rounded"></div>
        </div>
    </div>
);

export const AdminFormSkeleton = () => (
    <div className="animate-pulse">
        <div className="row g-4">
            <div className="col-sm-6">
                <div className="bg-gray-200 h-4 w-24 rounded mb-2"></div>
                <div className="bg-gray-200 h-10 w-full rounded"></div>
            </div>
            <div className="col-sm-6">
                <div className="bg-gray-200 h-4 w-24 rounded mb-2"></div>
                <div className="bg-gray-200 h-10 w-full rounded"></div>
            </div>
            <div className="col-sm-12">
                <div className="bg-gray-200 h-4 w-24 rounded mb-2"></div>
                <div className="bg-gray-200 h-24 w-full rounded"></div>
            </div>
        </div>
        <div className="mt-4">
            <div className="bg-gray-200 h-10 w-24 rounded mr-2 inline-block"></div>
            <div className="bg-gray-200 h-10 w-24 rounded inline-block"></div>
        </div>
    </div>
);
```

### Progressive Loading Pattern
```jsx
// admin/src/components/ProgressiveAdminLoader.jsx
import React, { useState, useEffect } from 'react';
import { AdminTableSkeleton } from './skeletons/AdminSkeletons';

const ProgressiveAdminLoader = ({ 
    children, 
    isLoading, 
    error, 
    fallback = <AdminTableSkeleton />,
    delayMs = 200 
}) => {
    const [showSkeleton, setShowSkeleton] = useState(false);

    useEffect(() => {
        let timer;
        
        if (isLoading) {
            // Delay showing skeleton to avoid flash for fast requests
            timer = setTimeout(() => {
                setShowSkeleton(true);
            }, delayMs);
        } else {
            setShowSkeleton(false);
        }

        return () => {
            if (timer) {
                clearTimeout(timer);
            }
        };
    }, [isLoading, delayMs]);

    if (error) {
        return (
            <div className="alert alert-danger">
                <h6>Error</h6>
                <p>{error.message}</p>
            </div>
        );
    }

    if (isLoading && showSkeleton) {
        return fallback;
    }

    return children;
};

export default ProgressiveAdminLoader;
```

## Code Splitting & Lazy Loading

### Admin Route Splitting
```jsx
// admin/src/route/AdminRoutes.jsx
import React, { Suspense } from 'react';
import { Routes, Route } from 'react-router-dom';
import { AdminTableSkeleton } from '../components/skeletons/AdminSkeletons';
import AdminErrorFallback from '../components/common/AdminErrorFallback';
import { ErrorBoundary } from 'react-error-boundary';

// Lazy load admin pages for better performance
const Dashboard = React.lazy(() => import('../pages/Dashboard'));
const UserManagement = React.lazy(() => import('../pages/UserManagement'));
const PropertyManagement = React.lazy(() => import('../pages/PropertyManagement'));
const BookingManagement = React.lazy(() => import('../pages/BookingManagement'));
const Analytics = React.lazy(() => import('../pages/Analytics'));
const Settings = React.lazy(() => import('../pages/Settings'));

// Preload critical routes
const preloadRoute = (routeComponent) => {
    return () => {
        routeComponent();
    };
};

// Preload dashboard after initial load
setTimeout(preloadRoute(() => import('../pages/Dashboard')), 1000);

const AdminRoutes = () => {
    return (
        <ErrorBoundary FallbackComponent={AdminErrorFallback}>
            <Suspense fallback={<AdminTableSkeleton />}>
                <Routes>
                    <Route path="/" element={<Dashboard />} />
                    <Route path="/users" element={<UserManagement />} />
                    <Route path="/properties" element={<PropertyManagement />} />
                    <Route path="/bookings" element={<BookingManagement />} />
                    <Route path="/analytics" element={<Analytics />} />
                    <Route path="/settings" element={<Settings />} />
                </Routes>
            </Suspense>
        </ErrorBoundary>
    );
};

export default AdminRoutes;
```

## Testing Patterns

### Admin Component Testing
```jsx
// admin/src/components/__tests__/AdminTable.test.jsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { AdminProvider } from '../../context/AdminContext';
import AdminTable from '../AdminTable';

// Test wrapper with providers
const TestWrapper = ({ children }) => {
    const queryClient = new QueryClient({
        defaultOptions: {
            queries: { retry: false },
            mutations: { retry: false }
        }
    });

    return (
        <QueryClientProvider client={queryClient}>
            <AdminProvider>
                {children}
            </AdminProvider>
        </QueryClientProvider>
    );
};

const mockData = [
    { id: 1, name: 'John Doe', email: 'john@example.com', status: 'active' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com', status: 'inactive' }
];

describe('AdminTable', () => {
    test('renders table with data', () => {
        render(
            <TestWrapper>
                <AdminTable data={mockData} />
            </TestWrapper>
        );

        expect(screen.getByText('John Doe')).toBeInTheDocument();
        expect(screen.getByText('Jane Smith')).toBeInTheDocument();
    });

    test('handles edit action', async () => {
        const onEdit = jest.fn();
        
        render(
            <TestWrapper>
                <AdminTable data={mockData} onEdit={onEdit} />
            </TestWrapper>
        );

        const editButtons = screen.getAllByText('Edit');
        fireEvent.click(editButtons[0]);

        await waitFor(() => {
            expect(onEdit).toHaveBeenCalledWith(mockData[0]);
        });
    });

    test('shows loading state', () => {
        render(
            <TestWrapper>
                <AdminTable data={[]} loading={true} />
            </TestWrapper>
        );

        expect(screen.getByRole('status')).toBeInTheDocument();
    });
});
```

## Performance Monitoring

### Admin Performance Hooks
```jsx
// admin/src/hooks/usePerformanceMonitor.js
import { useEffect, useRef } from 'react';

export const usePerformanceMonitor = (componentName) => {
    const renderStart = useRef(performance.now());
    const renderCount = useRef(0);

    useEffect(() => {
        renderCount.current += 1;
        const renderEnd = performance.now();
        const renderTime = renderEnd - renderStart.current;

        if (process.env.NODE_ENV === 'development') {
            console.log(`[${componentName}] Render #${renderCount.current}: ${renderTime.toFixed(2)}ms`);
        }

        // Send to analytics in production
        if (process.env.NODE_ENV === 'production' && renderTime > 100) {
            // Report slow renders
            console.warn(`Slow render detected: ${componentName} took ${renderTime.toFixed(2)}ms`);
        }

        renderStart.current = performance.now();
    });

    return {
        renderCount: renderCount.current,
        componentName
    };
};

// Memory usage monitor
export const useMemoryMonitor = () => {
    useEffect(() => {
        const checkMemory = () => {
            if (performance.memory) {
                const { usedJSHeapSize, totalJSHeapSize, jsHeapSizeLimit } = performance.memory;
                const memoryUsage = (usedJSHeapSize / jsHeapSizeLimit) * 100;

                if (memoryUsage > 80) {
                    console.warn(`High memory usage: ${memoryUsage.toFixed(2)}%`);
                }
            }
        };

        const interval = setInterval(checkMemory, 30000); // Check every 30 seconds
        return () => clearInterval(interval);
    }, []);
};
```

## Admin Development Best Practices

### Code Organization
- Group related admin components by feature/domain
- Use consistent naming conventions (Admin prefix for admin-specific components)
- Implement proper TypeScript types for better development experience
- Create reusable admin hooks and utilities

### Performance Guidelines
- Use React.memo for expensive admin components
- Implement virtual scrolling for large data tables
- Lazy load admin routes and heavy components
- Optimize API calls with proper caching strategies
- Monitor bundle size and split code appropriately

### Error Handling
- Implement error boundaries for each admin section
- Provide meaningful error messages for admin users
- Log errors for debugging and monitoring
- Handle network failures gracefully

### Accessibility
- Ensure all admin forms are keyboard navigable
- Provide proper ARIA labels for screen readers
- Maintain sufficient color contrast for admin themes
- Test admin interface with accessibility tools